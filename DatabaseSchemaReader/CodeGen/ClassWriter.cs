using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Mail;
using System.Text.RegularExpressions;
using DatabaseSchemaReader.CodeGen.CodeFirst;
using DatabaseSchemaReader.DataSchema;

namespace DatabaseSchemaReader.CodeGen
{
    public class ClassWriter
    {
        private readonly DatabaseTable _table;
        private readonly ClassBuilder _cb;
        private DataAnnotationWriter _dataAnnotationWriter;
        private readonly CodeWriterSettings _codeWriterSettings;
        private DatabaseTable _inheritanceTable;

        private IEnumerable<string> _logicalDeleteColumns;
        //private CodeInserter _codeInserter;

        public ClassWriter(DatabaseTable table, CodeWriterSettings codeWriterSettings, IEnumerable<string> logicalDeleteColumns)
        {
            _codeWriterSettings = codeWriterSettings;
            _table = table;
            _cb = new ClassBuilder();
            _logicalDeleteColumns = logicalDeleteColumns;
            //_codeInserter = codeWriterSettings.CodeInserter;
            //if (_codeInserter == null) _codeInserter = new CodeInserter();
        }

        public string Write()
        {
            var codeTarget = _codeWriterSettings.CodeTarget;
            _dataAnnotationWriter = new DataAnnotationWriter(false, _codeWriterSettings);

            if (string.IsNullOrEmpty(_table.NetName) && _table.DatabaseSchema != null)
            {
                PrepareSchemaNames.Prepare(_table.DatabaseSchema, _codeWriterSettings.Namer);
            }

            _inheritanceTable = _table.FindInheritanceTable();

            _codeWriterSettings.CodeInserter.WriteNamespaces(_table, _cb);

            _cb.AppendLine(@"//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by a Tool.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
//
//    Behavior of class members defined in this file may be changed by overriding in a derived class.
// </auto-generated>
//------------------------------------------------------------------------------");

            WriteUsings();
            _cb.AppendLine("");
            if (!string.IsNullOrEmpty(_codeWriterSettings.Namespace))
            {
                _cb.BeginNest("namespace " + _codeWriterSettings.Namespace);
            }
            
            var tableOrView = _table is DatabaseView ? "view" : "table";
            var comment = "Class representing the " + _table.Name + " " + tableOrView + ".";
            var classDefinition = "public class " + _table.NetName;
            if (_inheritanceTable != null)
            {
                classDefinition += " : " + _inheritanceTable.NetName;
            }

            _codeWriterSettings.CodeInserter.WriteTableAnnotations(_table, _cb);

            _cb.AppendXmlSummary(comment);
            _cb.AppendLine($"[Table(\"\\\"{_table.Name}\\\"\")]");
            using (_cb.BeginNest(classDefinition, comment))
            {
                WriteClassMembers();
            }

            if (!string.IsNullOrEmpty(_codeWriterSettings.Namespace))
            {
                _cb.EndNest();
            }

            return _cb.ToString();
        }

        private void WriteClassMembers()
        {
            _codeWriterSettings.CodeInserter.WriteClassMembers(_table, _cb);

            _cb.AppendLine("#region Primitive Properties");
            if (_inheritanceTable == null)
            {
                WritePrimaryKey();
            }

            foreach (var column in _table.Columns)
            {
                if (column.IsPrimaryKey) continue;
                //if (column.IsForeignKey) continue;
                WriteColumn(column);
            }
            _cb.AppendLine("#endregion");
            _cb.AppendLine("");

            _cb.AppendLine("#region Navigation Properties");
            foreach (var foreignKey in _table.ForeignKeys)
            {
                WriteForeignKey(foreignKey);
            }

            WriteForeignKeyCollections();
            _cb.AppendLine("#endregion");

            _cb.AppendLine("");
            _cb.AppendLine("#region CRUD Methods");
            _cb.AppendLine("public IDbContext DbContext { get; set; }");
            _cb.AppendLine("");
            WriteDelete();
            _cb.AppendLine("");
            WriteUpdate();
            _cb.AppendLine("");
            WriteCreate();
            _cb.AppendLine("");
            WriteGetters();
            WriteWiths();
            _cb.AppendLine("#endregion");
        }

        private string GetAllColumnNames()
        {
            return string.Join(", ", _table.Columns.Select(c => $"\\\"{c.Name}\\\""));
        }

        private IEnumerable<DatabaseColumn> GetInverseForeignKeyReferencedColumns()
        {
            var c = new List<DatabaseColumn>();
            foreach (var ifk in _table.InverseForeignKeys(_table))
            {
                if (ifk.RefersToTable != ifk.TableName)
                {
                    foreach (var rc in ifk.ReferencedColumns(_table.DatabaseSchema))
                    {
                        c.Add(ifk.ReferencedTable(_table.DatabaseSchema).FindColumn(rc));
                    }
                }
                else
                {
                    foreach (var _c in ifk.Columns)
                    {
                        c.Add(ifk.ReferencedTable(_table.DatabaseSchema).FindColumn(_c));
                    }
                }
            }

            return c;
        }

        private IEnumerable<DatabaseColumn> GetForeignKeyColumns()
        {
            var c = new List<DatabaseColumn>();
            foreach (var fk in _table.ForeignKeys)
            {
                if (fk.RefersToTable == fk.TableName)
                {
                    foreach (var rc in fk.ReferencedColumns(_table.DatabaseSchema))
                    {
                        c.Add(_table.FindColumn(rc));
                    }
                }
                else
                {
                    foreach (var _c in fk.Columns)
                    {
                        c.Add(_table.FindColumn(_c));
                    }
                }
            }

            return c;
        }

        private void WriteGetters()
        {
            // Get a list of primary keys
            // Find all combinations of the list
            // Write a GetSingle method for the combination of all primary keys
            // For each other combination, write a GetList method

            var primaryKeyColumns = _table.Columns.Where(c => c.IsPrimaryKey);
            WriteGet();
            _cb.AppendLine("");

            WriteGetList();
            _cb.AppendLine("");

            List<IEnumerable<DatabaseColumn>> combinations = null;
            var allKeys = new List<DatabaseColumn>();
            allKeys.AddRange(primaryKeyColumns);
            allKeys.AddRange(GetInverseForeignKeyReferencedColumns());
            allKeys.AddRange(GetForeignKeyColumns());
            for (var i = 1; i <= allKeys.Distinct().Count(); i++)
            {
                if (combinations == null)
                {
                    combinations = new List<IEnumerable<DatabaseColumn>>();
                }

                var c = allKeys.Distinct().DifferentCombinations(i);
                combinations.AddRange(c);
            }

            if (combinations == null)
            {
                return;
            }

            foreach (var c in combinations)
            {
                if (c.SequenceEqual(primaryKeyColumns))
                {
                    continue;
                }

                WriteGetListBy(c);
                _cb.AppendLine("");
            }
        }

        private void WriteGetList()
        {
            _cb.AppendXmlSummary(
                $"Queries the database for each instance.",
                $"A list of instances of <see cref=\"{_table.NetName}\"/>, or an empty list if are none.",
                $"This method returns shallow instances of <see cref=\"{_table.NetName}\"/>, i.e., it does not recurse."
            );

            using (_cb.BeginNest($"public static IEnumerable<{_table.NetName}> GetList(IDbContext dbc)"))
            {
                var sqlCommandText = $@"$""SELECT {GetAllColumnNames()} FROM \""{_table.Name}\"";""";
                var logicalDeleteColumn = _table.Columns.SingleOrDefault(c => _logicalDeleteColumns.Contains(c.Name));
                if (logicalDeleteColumn != null)
                {
                    sqlCommandText = $@"$""SELECT {GetAllColumnNames()} FROM \""{_table.Name}\"" WHERE \""{ logicalDeleteColumn.Name}\"" IS NULL;""";
                }

                _cb.AppendLine($"var entities = new List<{_table.NetName}>();");
                WriteExecuteReaderBlock(
                    sqlCommandText,
                    cb => { },
                    cb =>
                        {
                            using (cb.BeginNest("while (reader.Read())"))
                            {
                                _cb.AppendLine($"var entity = new {_table.NetName}();");
                                WriteParseEntityFromReader("entity");
                                _cb.AppendLine("entity.DbContext = dbc;");
                                _cb.AppendLine("entities.Add(entity);");
                            }
                        });
                _cb.AppendLine("");
                _cb.AppendLine("return entities;");
            }
        }

        private void WriteGetListBy(IEnumerable<DatabaseColumn> columns)
        {
            var methodParameters = GetMethodParametersForColumns(columns);
            var methodName = $"GetListBy{string.Join("And", methodParameters.Select(mp => _codeWriterSettings.Namer.NameColumnAsMethodTitle(mp.ColumnNameToQueryBy)))}";

            var _params = new List<Parameter>(methodParameters);
            _params.Insert(0, GetDbContextMethodParameter());
            _cb.AppendXmlSummary(
                $"Queries the database for each instance whose properties match the specified values.",
                $"A list of instances of <see cref=\"{_table.NetName}\"/>, or an empty list if there are no matches.",
                $"This method returns shallow instances of <see cref=\"{_table.NetName}\"/>, i.e., it does not recurse.",
                null,
                _params
            );

            using (_cb.BeginNest($"public static IEnumerable<{_table.NetName}> {methodName}({PrintParametersForSignature(_params)})"))
            {
                var whereClause = GetWhereClauseFromMethodParameters(methodParameters);
                var sqlCommandText = $"$\"SELECT {GetAllColumnNames()} FROM \\\"{_table.Name}\\\" WHERE {whereClause};\"";
                _cb.AppendLine($"var entities = new List<{_table.NetName}>();");
                WriteExecuteReaderBlock(
                    sqlCommandText, cb =>
                        {
                            foreach (var mp in methodParameters)
                            {
                                _cb.AppendLine($"dbc.AddParameter(command, \"@{mp.Name}\", {mp.Name});");
                            }
                        },
                    cb =>
                        {
                            using (cb.BeginNest("while (reader.Read())"))
                            {
                                _cb.AppendLine($"var entity = new {_table.NetName}();");
                                WriteParseEntityFromReader("entity");
                                _cb.AppendLine("entity.DbContext = dbc;");
                                _cb.AppendLine("entities.Add(entity);");
                            }
                        });
                _cb.AppendLine("");
                _cb.AppendLine("return entities;");
            }
        }

        private string GetWhereClauseFromMethodParameters(List<Parameter> methodParameters)
        {
            var whereClauseElements = methodParameters.Select(mp => $"\\\"{mp.ColumnNameToQueryBy}\\\" = @{mp.Name}").ToList();
            var logicalDeleteColumn = _table.Columns.SingleOrDefault(c => _logicalDeleteColumns.Contains(c.Name));
            if (logicalDeleteColumn != null)
            {
                whereClauseElements.Add($"\\\"{logicalDeleteColumn.Name}\\\" IS NULL");
            }

            var whereClause = string.Join(" AND ", whereClauseElements);
            return whereClause;
        }

        private void WriteDelete()
        {
            var isLogicalDelete = _table.Columns.Any(c => _logicalDeleteColumns.Contains(c.Name));
            if (isLogicalDelete)
            {
                WriteDeleteLogical();
                _cb.AppendLine("");
            }

            WriteDeletePhysical();
            _cb.AppendLine("");

            var methodParameters = GetMethodParametersForColumns(_table.Columns.Where(c => c.IsPrimaryKey));
            methodParameters.Insert(0, GetDbContextMethodParameter());
            _cb.AppendXmlSummary(
                $"Deletes the specified <see cref=\"{_table.NetName}\"/> from the database.",
                $"The deleted instance of <see cref=\"{_table.NetName}\"/> with fully-populated and updated properties (logical/soft delete), or <c>null</c> (physical/hard delete).",
                $"Logical/soft delete is performed if possible (i.e., the table has a column for storing the deleted timestamp).",
                new List<Tuple<string, string>>()
                    {
                        new Tuple<string, string>("EntityNotFoundException", "<paramref name=\"entity\"/> is not found in the database."),
                        new Tuple<string, string>("EntityHasDependenciesException", "<paramref name=\"entity\"/> cannot be deleted because it is still referenced in the database.")
                    },
                methodParameters);

            _cb.BeginNest($"public static {_table.NetName} Delete({PrintParametersForSignature(methodParameters)})");
            if (isLogicalDelete)
            {
                _cb.AppendLine($"var deletedEntity = DeleteLogical({PrintParametersForCall(methodParameters)});");
                _cb.BeginNest($"if (deletedEntity == null)");
                _cb.AppendLine($"throw new EntityNotFoundException();");
                _cb.EndNest();
                _cb.AppendLine("");
                _cb.AppendLine("return deletedEntity;");
            }
            else
            {
                _cb.AppendLine("int countRowsAffected = -1;");
                _cb.BeginNest("try");
                _cb.AppendLine($"countRowsAffected = DeletePhysical({PrintParametersForCall(methodParameters)});");
                _cb.EndNest();
                _cb.BeginNest("catch (Exception e)");
                _cb.BeginNest($"if (e is Npgsql.PostgresException pge && pge.SqlState == \"23503\")");
                _cb.AppendLine("throw new EntityHasDependenciesException();");
                _cb.EndNest();
                _cb.AppendLine("");
                _cb.AppendLine("throw;");
                _cb.EndNest();
                _cb.AppendLine("");
                _cb.BeginNest("if (countRowsAffected == 0)");
                _cb.AppendLine("throw new EntityNotFoundException();");
                _cb.EndNest();
                _cb.AppendLine("");
                _cb.BeginNest("if (countRowsAffected != 1)");
                _cb.AppendLine("throw new Exception(\"Delete affected more than one row.\");");
                _cb.EndNest();
                _cb.AppendLine("");
                _cb.AppendLine("return null;");
            }
            _cb.EndNest();
        }

        private void WriteDeleteLogical()
        {
            var methodParameters = GetMethodParametersForColumns(_table.Columns.Where(c => c.IsPrimaryKey));
            var _params = new List<Parameter>(methodParameters);
            _params.Insert(0, GetDbContextMethodParameter());
            using (_cb.BeginNest($"internal static {_table.NetName} DeleteLogical({PrintParametersForSignature(_params)})"))
            {
                var whereClause = GetWhereClauseFromMethodParameters(methodParameters);
                var logicalDeleteColumn = _table.Columns.Single(c => _logicalDeleteColumns.Contains(c.Name));
                var setClause = $"\\\"{logicalDeleteColumn.Name}\\\" = NOW()";
                var sqlCommandText = $"\"UPDATE \\\"{_table.Name}\\\" SET {setClause} WHERE {whereClause} RETURNING {GetAllColumnNames()};\";";
                var entityVariableName = "deletedEntity";
                _cb.AppendLine($"{_table.NetName} {entityVariableName} = null;");
                WriteExecuteReaderBlock(
                    sqlCommandText,
                    cb =>
                        {
                            foreach (var mp in methodParameters)
                            {
                                _cb.AppendLine($"dbc.AddParameter(command, \"@{mp.Name}\", {mp.Name});");
                            }
                        },
                    cb =>
                        {
                            using (cb.BeginNest("if (reader.Read())"))
                            {
                                _cb.AppendLine($"{entityVariableName} = new {_table.NetName}();");
                                WriteParseEntityFromReader(entityVariableName);
                            }
                        });
                WriteReturnEntityIfNotNull(entityVariableName);
            }
        }

        private void WriteDeletePhysical()
        {
            var methodParameters = GetMethodParametersForColumns(_table.Columns.Where(c => c.IsPrimaryKey));
            var _params = new List<Parameter>(methodParameters);
            _params.Insert(0, GetDbContextMethodParameter());
            _cb.BeginNest($"internal static int DeletePhysical({PrintParametersForSignature(_params)})");
            var wc = string.Join(" AND ", methodParameters.Select(mp => $"\\\"{mp.ColumnNameToQueryBy}\\\" = @{mp.Name}"));

            var sql = $"DELETE FROM \\\"{_table.Name}\\\" WHERE {wc};";
            _cb.BeginNest($"using (var connection = dbc.CreateConnection())");
            _cb.BeginNest($"using (var command = connection.CreateCommand())");
            _cb.AppendLine($"command.CommandText = \"{sql}\";");
            foreach (var mp in methodParameters)
            {
                _cb.AppendLine($"dbc.AddParameter(command, \"{mp.Name}\", {mp.Name});");
            }

            _cb.AppendLine("connection.Open();");
            _cb.AppendLine($"return command.ExecuteNonQuery();");
            _cb.EndNest();
            _cb.EndNest();
            _cb.EndNest();
        }

        /// <summary>
        /// 
        /// </summary>
        
        private void WriteUpdate()
        {
            var methodParameters = GetMethodParametersForColumns(_table.Columns.Where(c => c.IsPrimaryKey));
            var _params = new List<Parameter>(methodParameters);
            _params.Insert(0, GetDbContextMethodParameter());
            _params.Add(new Parameter { Name = "entity", Summary = "An entity with updated values.", DataType = _table.NetName });

            _cb.AppendXmlSummary(
                $"Updates the specified <see cref=\"{_table.NetName}\"/> in the database.",
                $"The updated instance of <see cref=\"{_table.NetName}\"/> with fully-populated and updated properties.",
                $"Method parameters specify the entity to be updated. Properties on <paramref name=\"entity\"/> that correspond to primary key columns on the \"{_table.Name}\" table are not updated.",
                null,
                _params
            );

            using (_cb.BeginNest($"public static {_table.NetName} Update({PrintParametersForSignature(_params)})"))
            {
                WriteGetPropertyColumnPairs();
                var whereClause = GetWhereClauseFromMethodParameters(methodParameters);
                _cb.AppendLine("var setClause = string.Join(\", \", propertyColumnPairs.Select(pcp => $\"{pcp.Value} = @{pcp.Key.Name}\"));");
                _cb.AppendLine($"var sqlCommandText = $\"UPDATE \\\"{_table.Name}\\\" SET {{setClause}} WHERE {whereClause} RETURNING {GetAllColumnNames()};\";");
                var entityVariableName = "updatedEntity";
                _cb.AppendLine($"{_table.NetName} {entityVariableName} = null;");
                WriteExecuteReaderBlock(
                    "sqlCommandText",
                    cb =>
                        {
                            foreach (var mp in methodParameters)
                            {
                                _cb.AppendLine($"dbc.AddParameter(command, \"@{mp.Name}\", {mp.Name});");
                            }

                            using (_cb.BeginNest($"foreach (var key in propertyColumnPairs.Keys)"))
                            {
                                _cb.AppendLine("dbc.AddParameter(command, $\"@{key.Name}\", key.GetValue(entity));");
                            }
                        },
                    cb =>
                        {
                            using (cb.BeginNest("if (reader.Read())"))
                            {
                                _cb.AppendLine($"{entityVariableName} = new {_table.NetName}();");
                                WriteParseEntityFromReader(entityVariableName);
                            }
                        });
                WriteReturnEntityIfNotNull(entityVariableName);
            }
        }

        private void WriteCreate()
        {
            var _params = new List<Parameter>()
                              {
                                  new Parameter()
                                      {
                                          Name = "dbc",
                                          Summary = "A database context.",
                                          DataType = "IDbContext"
                                      },
                                  new Parameter()
                                      {
                                          Name = "entity",
                                          Summary = "An entity to insert.",
                                          DataType = _table.NetName
                                      }
                              };

            _cb.AppendXmlSummary(
                $"Inserts the specified <see cref=\"{_table.NetName}\"/> to the database.",
                $"The inserted instance of <see cref=\"{_table.NetName}\"/> with fully-populated properties.",
                $"This method ignores properties on <see cref=\"{_table.NetName}\"/> that correspond to columns with auto-generated sequences, and properties whose values are default and corresond to nullable columns with default values.",
                null,
                _params
            );

            using (_cb.BeginNest($"public static {_table.NetName} Create({PrintParametersForSignature(_params)})"))
            {
                WriteGetPropertyColumnPairs();
                _cb.AppendLine("var valuesClause = string.Join(\", \", propertyColumnPairs.Keys.Select(k => \"@\" + k.Name));");
                _cb.AppendLine($"var sqlCommandText = $\"INSERT INTO \\\"{_table.Name}\\\" ({{string.Join(\", \", propertyColumnPairs.Values)}}) VALUES ({{valuesClause}}) RETURNING {GetAllColumnNames()};\";");

                var entityVariableName = "createdEntity";
                _cb.AppendLine($"{_table.NetName} {entityVariableName} = null;");
                WriteExecuteReaderBlock(
                    "sqlCommandText", cb =>
                        {
                            using (_cb.BeginNest($"foreach (var key in propertyColumnPairs.Keys)"))
                            {
                                _cb.AppendLine("dbc.AddParameter(command, $\"@{key.Name}\", key.GetValue(entity));");
                            }
                        },
                    cb =>
                        {
                            using (cb.BeginNest("if (reader.Read())"))
                            {
                                _cb.AppendLine($"{entityVariableName} = new {_table.NetName}();");
                                WriteParseEntityFromReader(entityVariableName);
                            }
                        });
                WriteReturnEntityIfNotNull(entityVariableName);
            }
        }

        private void WriteGetPropertyColumnPairs()
        {
            _cb.AppendLine($"var columnProperties = entity.GetType().GetProperties().Where(p => p.IsDefined(typeof(ColumnAttribute), false));");
            _cb.AppendLine($"var propertyColumnPairs = new Dictionary<PropertyInfo, string>();");
            using (_cb.BeginNest($"foreach (var cp in columnProperties)"))
            {
                _cb.AppendLine($"var columnAttribute = (ColumnAttribute)cp.GetCustomAttribute(typeof(ColumnAttribute));");
                _cb.AppendLine($"var dbGeneratedAttribute = (DatabaseGeneratedAttribute)cp.GetCustomAttribute(typeof(DatabaseGeneratedAttribute));");
                using (_cb.BeginNest($"if (dbGeneratedAttribute != null && dbGeneratedAttribute.DatabaseGeneratedOption == DatabaseGeneratedOption.Identity)")
                )
                {
                    _cb.AppendLine("continue;");
                }

                _cb.AppendLine("");
                using (_cb.BeginNest($"if (dbGeneratedAttribute != null && dbGeneratedAttribute.DatabaseGeneratedOption == DatabaseGeneratedOption.Computed)"))
                {
                    _cb.AppendLine($"var defaultValue = cp.PropertyType.IsValueType ? Activator.CreateInstance(cp.PropertyType) : null;");
                    using (_cb.BeginNest($"if (cp.GetValue(entity).Equals(defaultValue))"))
                    {
                        _cb.AppendLine("continue;");
                    }
                }

                _cb.AppendLine("");
                _cb.AppendLine($"propertyColumnPairs.Add(cp, columnAttribute.Name);");
            }

            _cb.AppendLine("");
        }

        private List<Parameter> GetMethodParametersForColumns(IEnumerable<DatabaseColumn> columns)
        {
            var methodParameters = new List<Parameter>();
            foreach (var column in columns)
            {
                var pn = _codeWriterSettings.Namer.NameParameter(PropertyName(column));
                var dt = DataTypeWriter.FindDataType(column);
                var cn = PropertyName(column);
                var fn = Regex.Replace(PropertyName(column), "([A-Z]+|[0-9]+)", " $1", RegexOptions.Compiled).Trim();
                var fields = fn.Split(' ').ToList();
                var firstChar = fields[0].ToLower()[0];
                if (firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || firstChar == 'o' || firstChar == 'u')
                {
                    fields.Insert(0, "An");
                }
                else
                {
                    fields.Insert(0, "A");
                }

                for (var i = 1; i < fields.Count; i++)
                {
                    var f = fields[i];
                    if (f.ToLower() == "id")
                    {
                        fields[i] = "ID";
                        continue;
                    }

                    fields[i] = fields[i].ToLower();
                }

                var summary = string.Join(" ", fields) + ".";

                methodParameters.Add(new Parameter() { Name = pn, DataType = dt, ColumnNameToQueryBy = cn, Summary = summary });
            }

            return methodParameters;
        }

        private Parameter GetDbContextMethodParameter()
        {
            return new Parameter()
            {
                DataType = "IDbContext",
                Name = "dbc",
                Summary = "A database context."
            };
        }

        private string PrintParametersForSignature(IEnumerable<Parameter> methodParameters)
        {
            return string.Join(", ", methodParameters.Select(mp => $"{mp.DataType} {mp.Name}"));
        }

        private string PrintParametersForCall(IEnumerable<Parameter> methodParameters)
        {
            return string.Join(", ", methodParameters.Select(mp => $"{mp.Name}"));
        }

        private void WriteGet()
        {
            var methodParameters = GetMethodParametersForColumns(_table.Columns.Where(c => c.IsPrimaryKey));
            var _params = new List<Parameter>(methodParameters);
            _params.Insert(0, GetDbContextMethodParameter());
            _cb.AppendXmlSummary(
                $"Queries the database for a single instance whose properties match the specified values.",
                $"An instance of <see cref=\"{_table.NetName}\"/>, or <c>null</c> if there is no match.",
                $"This method gets only primitive properties, i.e., only properties that correspond to columns on the database table. No recursion is performed.",
                new List<Tuple<string, string>>()
                {
                                new Tuple<string, string>("ArgumentNullException", "<paramref name=\"filter\"/> is <c>null</c> or empty."),
                                new Tuple<string, string>("InvalidOperationException", "There are multiple matches in the database.")
                },
                _params);

            using (_cb.BeginNest($"public static {_table.NetName} Get({PrintParametersForSignature(_params)})"))
            {
                var whereClause = GetWhereClauseFromMethodParameters(methodParameters);
                var sqlCommandText = $"$\"SELECT {GetAllColumnNames()} FROM \\\"{_table.Name}\\\" WHERE {whereClause};\"";
                var entityVariableName = "entity";
                _cb.AppendLine($"{_table.NetName} {entityVariableName} = null;");
                WriteExecuteReaderBlock(
                    sqlCommandText, cb =>
                        {
                            foreach (var mp in methodParameters)
                            {
                                _cb.AppendLine($"dbc.AddParameter(command, \"@{mp.Name}\", {mp.Name});");
                            }
                        },
                    cb =>
                        {
                            using (cb.BeginNest("if (reader.Read())"))
                            {
                                _cb.AppendLine($"{entityVariableName} = new {_table.NetName}();");
                                WriteParseEntityFromReader(entityVariableName);
                            }
                        });
                WriteReturnEntityIfNotNull(entityVariableName);
            }
        }

        private void WriteExecuteReaderBlock(string sqlCommandText, Action<ClassBuilder> addCommandParameters, Action<ClassBuilder> processReader)
        {
            using (_cb.BeginNest($"using (var connection = dbc.CreateConnection())"))
            {
                _cb.AppendLine("connection.Open();");
                using (_cb.BeginNest($"using (var command = connection.CreateCommand())"))
                {
                    _cb.AppendLine($"command.CommandText = {sqlCommandText};");
                    addCommandParameters(_cb);

                    using (_cb.BeginNest("using (var reader = command.ExecuteReader())"))
                    {
                        processReader(_cb);
                    }
                }
            }
        }

        private void WriteReturnEntityIfNotNull(string entityVariableName)
        {
            _cb.AppendLine("");
            using (_cb.BeginNest($"if ({entityVariableName} == null)"))
            {
                _cb.AppendLine("return null;");
            }

            _cb.AppendLine("");
            _cb.AppendLine($"{entityVariableName}.DbContext = dbc;");
            _cb.AppendLine($"return {entityVariableName};");
        }

        private void WriteParseEntityFromReader(string entityVariableName)
        {
            foreach (var c in _table.Columns.Where(c => c.DbDataType != "geometry" && c.DbDataType != "geography"))
            {
                if (c.Nullable)
                {
                    _cb.AppendLine($"{entityVariableName}.{PropertyName(c)} = reader.GetValue({c.Ordinal - 1}) == DBNull.Value ? null : ({DataTypeWriter.FindDataType(c)})reader.GetValue({c.Ordinal - 1});");
                }
                else
                {
                    _cb.AppendLine($"{entityVariableName}.{PropertyName(c)} = ({DataTypeWriter.FindDataType(c)})reader.GetValue({c.Ordinal - 1});");
                }
            }
        }

        private void WriteWiths()
        {
            foreach (var foreignKey in _table.ForeignKeys)
            {
                WriteWith(foreignKey);
                _cb.AppendLine("");
            }

            foreach (var foreignKey in _table.ForeignKeyChildren)
            {
                WriteWith(foreignKey);
                _cb.AppendLine("");
            }
        }

        public void WriteWith(DatabaseTable foreignKeyChild)
        {
            var fks = foreignKeyChild.ForeignKeys.Where(fk => fk.ReferencedTable(_table.DatabaseSchema).Name == _table.Name);
            foreach (var fk in fks)
            {
                var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKeyChild, fk);
                var dataType = foreignKeyChild.NetName;
                if (fk.Columns.Count != fk.ReferencedColumns(_table.DatabaseSchema).Count())
                {
                    throw new InvalidOperationException("Number of foreign key columns does not match number of columns referenced!");
                }

                var referencedColumns = fk.ReferencedColumns(_table.DatabaseSchema).ToList();
                var methodParameters = new List<Tuple<string, string, string>>();
                for (var i = 0; i < fk.Columns.Count; i++)
                {
                    var refColumn = fk.Columns[i];
                    var column = referencedColumns[i];
                    var actualColumn = _table.Columns.Single(tc => tc.Name == column);
                    var dataTypeForParameter = DataTypeWriter.FindDataType(actualColumn);
                    methodParameters.Add(new Tuple<string, string, string>(_codeWriterSettings.Namer.NameParameter(refColumn), dataTypeForParameter, refColumn));
                }

                _cb.BeginNest($"public {_table.NetName} With{propertyName}()");

                var methodCallParameters = new List<string>
                {
                    "this.DbContext"
                };

                foreach (var fkc in fk.Columns)
                {
                    var tc = _table.Columns.Single(_tc => _tc.Name == fkc);
                    var parameter = $"this.{PropertyName(tc)}";
                    if (DataTypeWriter.FindDataType(tc).EndsWith("?"))
                    {
                        parameter += ".Value";
                    }

                    methodCallParameters.Add(parameter);
                }

                var s = string.Join(", ", methodCallParameters);
                var methodName = $"GetListBy{string.Join("And", methodParameters.Select(mp => _codeWriterSettings.Namer.NameColumnAsMethodTitle(mp.Item3)))}";
                _cb.AppendLine($"this.{propertyName} = {dataType}.{methodName}({s});");
                _cb.AppendLine("return this;");
                _cb.EndNest();
            }
        }

        public void WriteWith(DatabaseConstraint foreignKey)
        {
            var propertyName = _codeWriterSettings.Namer.ForeignKeyName(_table, foreignKey);
            var refTable = foreignKey.ReferencedTable(_table.DatabaseSchema);
            var dataType = refTable.NetName;

            if (foreignKey.Columns.Count != foreignKey.ReferencedColumns(_table.DatabaseSchema).Count())
            {
                throw new InvalidOperationException("Number of foreign key columns does not match number of columns referenced!");
            }

            _cb.BeginNest($"public {_table.NetName} With{propertyName}()");

            var methodCallParameters = new List<string>
            {
                "this.DbContext"
            };

            foreach (var fkc in foreignKey.Columns)
            {
                var tc = _table.Columns.Single(_tc => _tc.Name == fkc);
                var parameter = $"this.{PropertyName(tc)}";
                if (DataTypeWriter.FindDataType(tc).EndsWith("?"))
                {
                    parameter += ".Value";
                }

                methodCallParameters.Add(parameter);
            }

            var s = string.Join(", ", methodCallParameters);
            _cb.AppendLine($"this.{propertyName} = {dataType}.Get({s});");
            _cb.AppendLine("return this;");
            _cb.EndNest();
        }

        private void WritePrimaryKey()
        {
            foreach (var column in _table.Columns.Where(c => c.IsPrimaryKey))
            {
                WriteColumn(column, false);
            }
        }

        private void WriteUsings()
        {
            _cb.AppendLine("using System;");
            _cb.AppendLine("using System.Collections.Generic;");
            _cb.AppendLine("using System.ComponentModel.DataAnnotations;");
            _cb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
            _cb.AppendLine("using System.Linq;");
            _cb.AppendLine("using System.Reflection;");

            _cb.AppendLine("");
            _cb.AppendLine("using PeopleNet.EnterpriseData.DataAccess.Exceptions;");
            _cb.AppendLine("using PeopleNet.EnterpriseData.DataAccess.Repositories;");
        }

        private void WriteForeignKeyCollections()
        {
            var listType = "IEnumerable<";

            var hasTablePerTypeInheritance =
                (_table.ForeignKeyChildren.Count(fk => _table.IsSharedPrimaryKey(fk)) > 1);

            foreach (var foreignKey in _table.ForeignKeyChildren)
            {
                if (foreignKey.IsManyToManyTable() && _codeWriterSettings.CodeTarget == CodeTarget.PocoEntityCodeFirst)
                {
                    WriteManyToManyCollection(foreignKey);
                    continue;
                }
                if (_table.IsSharedPrimaryKey(foreignKey))
                {
                    if (hasTablePerTypeInheritance)
                        continue;
                    //type and property name are the same
                    _cb.AppendAutomaticProperty(foreignKey.NetName, foreignKey.NetName, true);
                    continue;
                }

                //the other table may have more than one fk pointing at this table
                var fks = _table.InverseForeignKeys(foreignKey);
                foreach (var fk in fks)
                {
                    var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKey, fk);
                    var dataType = listType + foreignKey.NetName + ">";
                    WriteForeignKeyChild(propertyName, dataType);
                }
            }
        }

        private void WriteForeignKeyChild(string propertyName, string dataType)
        {
            if (_codeWriterSettings.CodeTarget == CodeTarget.PocoRiaServices)
                _cb.AppendLine("[Include]");
            _cb.AppendAutomaticCollectionProperty(dataType, propertyName, false);
        }

        private void WriteManyToManyCollection(DatabaseTable foreignKey)
        {
            //look over the junction table to find the other many-to-many end
            var target = foreignKey.ManyToManyTraversal(_table);
            if (target == null)
            {
                Debug.WriteLine("Can't navigate the many to many relationship for " + _table.Name + " to " + foreignKey.Name);
                return;
            }
            var propertyName = _codeWriterSettings.Namer.NameCollection(target.NetName);
            var dataType = "ICollection<" + target.NetName + ">";
            _cb.AppendAutomaticCollectionProperty(dataType, propertyName, false);

        }

        private void WriteManyToManyInitialize(DatabaseTable foreignKey)
        {
            //look over the junction table to find the other many-to-many end
            var target = foreignKey.ManyToManyTraversal(_table);
            if (target == null)
            {
                return;
            }
            var propertyName = _codeWriterSettings.Namer.NameCollection(target.NetName);
            var dataType = "List<" + target.NetName + ">";
            _cb.AppendLine(propertyName + " = new " + dataType + "();");
        }

        private void InitializeCollectionsInConstructor()
        {
            if (!_table.ForeignKeyChildren.Any()) return;
            using (_cb.BeginNest("public " + _table.NetName + "()"))
            {
                foreach (var foreignKey in _table.ForeignKeyChildren)
                {
                    if (foreignKey.IsManyToManyTable() && _codeWriterSettings.CodeTarget == CodeTarget.PocoEntityCodeFirst)
                    {
                        WriteManyToManyInitialize(foreignKey);
                        continue;
                    }
                    if (_table.IsSharedPrimaryKey(foreignKey))
                    {
                        continue;
                    }
                    var fks = _table.InverseForeignKeys(foreignKey);
                    foreach (DatabaseConstraint fk in fks)
                    {
                        var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKey, fk);
                        var dataType = "List<" + foreignKey.NetName + ">";
                        _cb.AppendLine(propertyName + " = new " + dataType + "();");
                    }
                }
            }
            _cb.AppendLine("");
        }

        private void WriteColumn(DatabaseColumn column)
        {
            WriteColumn(column, false);
        }

        private void WriteColumn(DatabaseColumn column, bool notNetName)
        {
            if (column.DbDataType.Contains("geography") || column.DbDataType.Contains("geometry"))
            {
                return;
            }

            var propertyName = PropertyName(column);
            var dataType = DataTypeWriter.FindDataType(column);

            if (notNetName)
            {
                //in EF, you want a fk Id property
                //must not conflict with entity fk name
                propertyName += "Id";
            }

            _codeWriterSettings.CodeInserter.WriteColumnAnnotations(_table, column, _cb);
            _dataAnnotationWriter.Write(_cb, column, propertyName);
            var useVirtual = true;
            _cb.AppendAutomaticProperty(dataType, propertyName, useVirtual);
        }

        internal static string PropertyName(DatabaseColumn column)
        {
            var propertyName = column.Name;
            //var propertyName = column.NetName;
            ////in case the netName hasn't been set
            //if (string.IsNullOrEmpty(propertyName)) propertyName = column.Name;
            //// KL: Ensures that property name doesn't match class name
            //if (propertyName == column.Table.NetName)
            //{
            //    propertyName = string.Format("{0}Column", propertyName);
            //}
            //if (column.IsPrimaryKey && column.IsForeignKey)
            //{
            //    //if it's a composite key as well, always write an Id version
            //    var table = column.Table;
            //    if (table != null && table.HasCompositeKey)
            //    {
            //        return propertyName + "Id";
            //    }
            //    //a foreign key will be written, so we need to avoid a collision
            //    var refTable = FindForeignKeyTable(column);
            //    var fkDataType = refTable != null ? refTable.NetName : column.ForeignKeyTableName;
            //    if (fkDataType == propertyName)
            //    {
            //        //in EF, you want a fk Id property
            //        //must not conflict with entity fk name
            //        propertyName += "Id";
            //    }
            //}
            return propertyName;
        }

        private static DatabaseTable FindForeignKeyTable(DatabaseColumn column)
        {
            var refTable = column.ForeignKeyTable;
            if (refTable != null) return refTable;
            //column may be in multiple fks, and the model may be broken
            var table = column.Table;
            if (table == null) return null;
            //find the first foreign key containing this column
            var fk = table.ForeignKeys.FirstOrDefault(c => c.Columns.Contains(column.Name));
            if (fk != null)
            {
                refTable = fk.ReferencedTable(table.DatabaseSchema);
            }
            return refTable;
        }

        private void WriteForeignKey(DatabaseConstraint foreignKey)
        {
            // get the reference table
            var refTable = foreignKey.ReferencedTable(_table.DatabaseSchema);

            //we inherit from it instead (problem with self-joins)
            if (Equals(refTable, _inheritanceTable)) return;

            if (refTable == null)
            {
                //we can't find the foreign key table, so just write the columns
                WriteForeignKeyColumns(foreignKey, "");
                return;
            }

            var propertyName = _codeWriterSettings.Namer.ForeignKeyName(_table, foreignKey);
            var dataType = refTable.NetName;

            _cb.AppendAutomaticProperty(dataType, propertyName);

            if (false && _codeWriterSettings.UseForeignKeyIdProperties)
            {
                WriteForeignKeyColumns(foreignKey, propertyName);
            }
        }

        private void WriteForeignKeyColumns(DatabaseConstraint foreignKey, string propertyName)
        {
            //for code first, we may have to write scalar properties
            //1 if the fk is also a pk
            //2 if they selected use Foreign Key Ids
            foreach (var columnName in foreignKey.Columns)
            {
                var column = _table.FindColumn(columnName);
                if (column == null) continue;
                //primary keys are already been written
                if (!column.IsPrimaryKey)
                {
                    WriteColumn(column, propertyName.Equals(column.NetName));
                }
            }
        }
    }
}
