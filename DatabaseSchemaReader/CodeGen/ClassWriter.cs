using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text.RegularExpressions;
using DatabaseSchemaReader.CodeGen.CodeFirst;
using DatabaseSchemaReader.DataSchema;

namespace DatabaseSchemaReader.CodeGen
{
    /// <summary>
    /// Turns a specified <see cref="DatabaseTable"/> into a C# class
    /// </summary>
    public class ClassWriter
    {
        private readonly DatabaseTable _table;
        private readonly ClassBuilder _cb;
        private readonly DataTypeWriter _dataTypeWriter = new DataTypeWriter();
        private DataAnnotationWriter _dataAnnotationWriter;
        private readonly CodeWriterSettings _codeWriterSettings;
        private DatabaseTable _inheritanceTable;
        //private CodeInserter _codeInserter;

        /// <summary>
        /// Initializes a new instance of the <see cref="ClassWriter"/> class.
        /// </summary>
        /// <param name="table">The table.</param>
        /// <param name="codeWriterSettings">The code writer settings.</param>
        public ClassWriter(DatabaseTable table, CodeWriterSettings codeWriterSettings)
        {
            _codeWriterSettings = codeWriterSettings;
            _table = table;
            _cb = new ClassBuilder();
            //_codeInserter = codeWriterSettings.CodeInserter;
            //if (_codeInserter == null) _codeInserter = new CodeInserter();
        }

        /// <summary>
        /// Writes the C# code of the table
        /// </summary>
        /// <returns></returns>
        public string Write()
        {
            var codeTarget = _codeWriterSettings.CodeTarget;
            _dataAnnotationWriter = new DataAnnotationWriter(IsEntityFramework(), _codeWriterSettings);
            var className = _table.NetName;
            if (string.IsNullOrEmpty(className) && _table.DatabaseSchema != null)
            {
                PrepareSchemaNames.Prepare(_table.DatabaseSchema, _codeWriterSettings.Namer);
                className = _table.NetName;
            }
            _dataTypeWriter.CodeTarget = codeTarget;

            _inheritanceTable = _table.FindInheritanceTable();

            _codeWriterSettings.CodeInserter.WriteNamespaces(_table, _cb);

            _cb.AppendLine(@"//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
//
//    Behavior of class members defined in this file may be changed by overriding in a derived class.
// </auto-generated>
//------------------------------------------------------------------------------");

            _cb.AppendLine("");
            if (!string.IsNullOrEmpty(_codeWriterSettings.Namespace))
            {
                _cb.BeginNest("namespace " + _codeWriterSettings.Namespace);
            }

            WriteUsings();
            _cb.AppendLine("");
            if (codeTarget == CodeTarget.PocoRiaServices)
            {
                WriteRiaClass(className);
            }
            else
            {
                var tableOrView = _table is DatabaseView ? "view" : "table";
                var comment = "Class representing the " + _table.Name + " " + tableOrView;
                var classDefinition = "public class " + className;
                if (_inheritanceTable != null)
                {
                    classDefinition += " : " + _inheritanceTable.NetName;
                }

                _codeWriterSettings.CodeInserter.WriteTableAnnotations(_table, _cb);

                using (_cb.BeginNest(classDefinition, comment))
                {
                    WriteClassMembers(className);
                }
            }

            //if (_table.HasCompositeKey && _inheritanceTable == null)
            //{
            //    WriteCompositeKeyClass(className);
            //}

            if (!string.IsNullOrEmpty(_codeWriterSettings.Namespace))
            {
                _cb.EndNest();
            }

            return _cb.ToString();
        }

        private void WriteRiaClass(string className)
        {
            _cb.AppendLine("[MetadataType(typeof(" + className + "." + className + "Metadata))]");
            using (_cb.BeginBrace("public partial class " + className))
            {
                //write the buddy class
                using (_cb.BeginNest("internal sealed class " + className + "Metadata"))
                {
                    WriteClassMembers(className);
                }
            }
        }

        private void WriteClassMembers(string className)
        {
            if (_codeWriterSettings.CodeTarget == CodeTarget.PocoRiaServices)
            {
                RiaServicesWriter.WritePrivateConstructor(className, _cb);
            }
            else
            {
                InitializeCollectionsInConstructor(className);
            }

            _codeWriterSettings.CodeInserter.WriteClassMembers(_table, _cb);

            _cb.AppendLine("#region Primitive Properties");
            if (_inheritanceTable == null)
                WritePrimaryKey(className);

            foreach (var column in _table.Columns)
            {
                if (column.IsPrimaryKey) continue;
                //if (column.IsForeignKey) continue;
                WriteColumn(column);
            }
            _cb.AppendLine("#endregion");
            _cb.AppendLine("");

            _cb.AppendLine("#region Navigation Properties");
            foreach (var foreignKey in _table.ForeignKeys)
            {
                WriteForeignKey(foreignKey);
            }

            WriteForeignKeyCollections();
            _cb.AppendLine("#endregion");

            _cb.AppendLine("");
            _cb.AppendLine("#region CRUD Methods");
            WriteGet(className);
            _cb.AppendLine("");

            WriteGet2(className);
            _cb.AppendLine("");

            WriteWiths(className);
            _cb.AppendLine("");
            WriteGetList(className);
            _cb.AppendLine("#endregion");

            // KE: skip writing ToString, Equals, and GetHashCode
            //if (!_table.HasCompositeKey &&
            //    _codeWriterSettings.CodeTarget != CodeTarget.PocoRiaServices &&
            //    _inheritanceTable == null)
            //{
            //    var overrider = new OverrideWriter(_cb, _table, _codeWriterSettings.Namer);
            //    overrider.AddOverrides();
            //}
        }

        private void WriteWiths(string className)
        {
            foreach (var foreignKey in _table.ForeignKeys)
            {
                WriteWith(className, foreignKey);
                _cb.AppendLine("");
            }

            foreach (var foreignKey in _table.ForeignKeyChildren)
            {
                WriteWith(className, foreignKey);
                _cb.AppendLine("");
            }
        }

        public void WriteWith(string className, DatabaseTable foreignKeyChild)
        {
            var fks = foreignKeyChild.ForeignKeys.Where(fk => fk.ReferencedTable(_table.DatabaseSchema).Name == _table.Name);
            foreach (var fk in fks)
            {
                // Get the foreign key referenced column name and then find the property name of this
                // Get the foreign key column name
                var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKeyChild, fk);
                var dataType = foreignKeyChild.NetName;
                if (fk.Columns.Count != fk.ReferencedColumns(_table.DatabaseSchema).Count())
                {
                    throw new InvalidOperationException("Number of foreign key columns does not match number of columns referended!");
                }

                var referencedColumns = fk.ReferencedColumns(_table.DatabaseSchema).ToList();
                var methodParameters = new List<Tuple<string, string>>();
                for (var i = 0; i < fk.Columns.Count; i++)
                {
                    var refColumn = fk.Columns[i];
                    var column = referencedColumns[i];
                    var fkPropertyName = PropertyName(_table.Columns.Single(tc => tc.Name == column));
                    var actualColumn = _table.Columns.Single(tc => tc.Name == column);
                    var dataTypeForParameter = _dataTypeWriter.Write(actualColumn);
                    methodParameters.Add(new Tuple<string, string>(_codeWriterSettings.Namer.NameParameter(refColumn), dataTypeForParameter));
                }

                var signatureParameters = String.Join(", ", methodParameters.Select(mp => $"{mp.Item2} {mp.Item1}"));
                _cb.BeginNest($"public {className} With{propertyName}({signatureParameters})");
                var callParameters = String.Join(", ", methodParameters.Select(mp => mp.Item1));
                _cb.AppendLine($"this.{propertyName} = {dataType}.GetList({callParameters});");
                _cb.AppendLine("return this;");
                _cb.EndNest();
            }
        }

        public void WriteWith(string className, DatabaseConstraint foreignKey)
        {
            var propertyName = _codeWriterSettings.Namer.ForeignKeyName(_table, foreignKey);
            var refTable = foreignKey.ReferencedTable(_table.DatabaseSchema);
            var dataType = refTable.NetName;

            if (foreignKey.Columns.Count != foreignKey.ReferencedColumns(_table.DatabaseSchema).Count())
            {
                throw new InvalidOperationException("Number of foreign key columns does not match number of columns referended!");
            }

            var referencedColumns = foreignKey.ReferencedColumns(_table.DatabaseSchema).ToList();
            var methodParameters = new List<Tuple<string, string>>();
            for (var i = 0; i < foreignKey.Columns.Count; i++)
            {
                var refColumn = referencedColumns[i];
                var column = foreignKey.Columns[i];
                var fkPropertyName = PropertyName(_table.Columns.Single(tc => tc.Name == column));
                var actualColumn = _table.Columns.Single(tc => tc.Name == column);
                var dataTypeForParameter = _dataTypeWriter.Write(actualColumn);
                methodParameters.Add(new Tuple<string, string>(_codeWriterSettings.Namer.NameParameter(refColumn), dataTypeForParameter));
            }

            var signatureParameters = String.Join(", ", methodParameters.Select(mp => $"{mp.Item2} {mp.Item1}"));
            _cb.BeginNest($"public {className} With{propertyName}({signatureParameters})");
            var callParameters = String.Join(", ", methodParameters.Select(mp => mp.Item1));
            _cb.AppendLine($"this.{propertyName} = {dataType}.Get({callParameters});");
            _cb.AppendLine("return this;");
            _cb.EndNest();
        }

        private void WriteGetList(string className)
        {
            _cb.AppendXmlSummary(
                $"Queries the database for each instance whose properties match the specified filter.",
                returns: $"A list of instances of <see cref=\"{className}\"/>, or an empty list if there are no matches.",
                parameters: new List<Tuple<string, string>>()
                {
                                new Tuple<string, string>("filter", "A set of key-value pairs for composing a SQL WHERE clause. Each key should be a string that matches one column name in the database table.")
                },
                remarks: $"This method returns shallow instances of <see cref=\"{className}\"/>, i.e., it does not recurse."
            );
            using (_cb.BeginNest($"public static IEnumerable<{className}> GetList(IDbConnection c, Dictionary<string, object> filter)"))
            {
                _cb.AppendLine($"var sqlQuery = $\"SELECT * FROM \\\"{_table.Name}\\\";\";");
                using (_cb.BeginNest("if (filter != null && filter.Count > 0)"))
                {
                    _cb.AppendLine($"var whereClause = String.Join(\" AND \", filter.Keys.Select(k => $\"\\\"{{k}}\\\" = '{{filter[k]}}'\"));");
                    _cb.AppendLine($"sqlQuery = $\"SELECT * FROM \\\"{_table.Name}\\\" WHERE {{whereClause}};\";");
                }

                _cb.AppendLine("");
                _cb.AppendLine($"var entities = c.Query<{className}>(sqlQuery);");

                _cb.AppendLine("");
                _cb.AppendLine("return entities;");
            }
        }

        private void WriteGetList2(string className)
        {
            foreach (var foreignKeyChild in _table.ForeignKeyChildren)
            {
                WriteForeignKeyChildGetter("entity", foreignKeyChild);
            }
        }

        private void WriteGet2(string className)
        {
            var methodParameters = new List<Tuple<string, string, string, string>>();
            foreach (var column in _table.Columns.Where(c => c.IsPrimaryKey))
            {
                var pn = _codeWriterSettings.Namer.NameParameter(PropertyName(column));
                var dt = _dataTypeWriter.Write(column);
                var cn = PropertyName(column);
                var fn = Regex.Replace(PropertyName(column), "([A-Z]+|[0-9]+)", " $1", RegexOptions.Compiled).Trim();
                var fields = fn.Split(' ').ToList();
                var firstChar = fields[0].ToLower()[0];
                if (firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || firstChar == 'o' || firstChar == 'u')
                {
                    fields.Insert(0, "An");
                }
                else
                {
                    fields.Insert(0, "A");
                }

                for (var i = 1; i < fields.Count; i++)
                {
                    var f = fields[i];
                    if (f.ToLower() == "id")
                    {
                        fields[i] = "ID";
                        continue;
                    }

                    fields[i] = fields[i].ToLower();
                }

                var summary = String.Join(" ", fields);

                methodParameters.Add(new Tuple<string, string, string, string>(pn, dt, cn, summary));
            }

            var signatureParameters = String.Join(", ", methodParameters.Select(mp => $"{mp.Item2} {mp.Item1}"));

            _cb.AppendXmlSummary(
                $"Queries the database for a single instance whose properties match the specified filter.",
                returns: $"An instance of <see cref=\"{className}\"/>, or <c>null</c> if there is no match.",
                exceptions: new List<Tuple<string, string>>()
                {
                                new Tuple<string, string>("ArgumentNullException", "<paramref name=\"filter\"/> is <c>null</c> or empty."),
                                new Tuple<string, string>("InvalidOperationException", "There are multiple matches in the database.")
                },
                parameters: methodParameters.Select(mp => new Tuple<string, string>(mp.Item1, mp.Item4)),
                remarks: $"This method gets only primitive properties, i.e., only properties that correspond to columns on the database table. No recursion is performed."
            );

            using (_cb.BeginNest($"public static {className} Get({signatureParameters})"))
            {
                var wc = String.Join(" AND ", methodParameters.Select(mp => $@"\""{mp.Item3}\"" = '{{{mp.Item1}}}'"));
                var sq = $@"$""SELECT * FROM \""{_table.Name}\"" WHERE {wc};""";
                _cb.AppendLine($"{className} entity;");
                using (_cb.BeginNest(@"using (var connection = new NpgsqlConnection(""Server = 127.0.0.1; User id = postgres; Pwd = 12345678; database = enterprise_data;""))"))
                {
                    _cb.AppendLine($"entity = connection.QuerySingleOrDefault<{className}>({sq});");
                }

                _cb.AppendLine("");

                _cb.AppendLine("return entity;");

            }

        }

        private void WriteGet(string className)
        {
            _cb.AppendXmlSummary(
                $"Queries the database for a single instance whose properties match the specified filter.",
                returns: $"An instance of <see cref=\"{className}\"/>, or <c>null</c> if there is no match.",
                exceptions: new List<Tuple<string, string>>()
                {
                    new Tuple<string, string>("ArgumentNullException", "<paramref name=\"filter\"/> is <c>null</c> or empty."),
                    new Tuple<string, string>("InvalidOperationException", "There are multiple matches in the database.")
                },
                parameters: new List<Tuple<string, string>>()
                {
                    new Tuple<string, string>("filter", "A set of key-value pairs for composing a SQL WHERE clause. Each key should be a string that matches one column name in the database table.")
                },
                remarks: $"This method recursively gets primitive and navigation properties. Navigation collection properties are populated by calling the <see cref=\"GetList\"/> method."
            );
            using (_cb.BeginNest($"public static {className} Get(IDbConnection c, Dictionary<string, object> filter)"))
            {
                using (_cb.BeginNest("if (filter == null || filter.Count < 1)"))
                {
                    _cb.AppendLine("throw new ArgumentNullException(\"Parameter 'filter' is null but must contain at least one key-value pair. Did you mean to call GetList?\");");
                }

                _cb.AppendLine("");
                _cb.AppendLine($"var whereClause = String.Join(\" AND \", filter.Keys.Select(k => $\"\\\"{{k}}\\\" = '{{filter[k]}}'\")); ");
                _cb.AppendLine($"var sqlQuery = $\"SELECT * FROM \\\"{_table.Name}\\\" WHERE {{whereClause}};\";");
                _cb.AppendLine($"var entity = c.QuerySingleOrDefault<{className}>(sqlQuery);");
                using (_cb.BeginNest("if (entity == null)"))
                {
                    _cb.AppendLine("return entity;");
                }

                _cb.AppendLine("");
                foreach (var foreignKey in _table.ForeignKeys)
                {
                    WriteForeignKeyGetter("entity", foreignKey);
                }

                foreach (var foreignKeyChild in _table.ForeignKeyChildren)
                {
                    WriteForeignKeyChildGetter("entity", foreignKeyChild);
                }

                _cb.AppendLine("return entity;");
            }
        }

        private void WriteForeignKeyChildGetter(string entityName, DatabaseTable foreignKeyChild)
        {
            var fks = foreignKeyChild.ForeignKeys.Where(fk => fk.ReferencedTable(_table.DatabaseSchema).Name == _table.Name);
            foreach (var fk in fks)
            {
                // Get the foreign key referenced column name and then find the property name of this
                // Get the foreign key column name
                var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKeyChild, fk);

                var dictionaryItems = new List<string>();
                var propertiesNullChecks = new List<string>();

                if (fk.Columns.Count != fk.ReferencedColumns(_table.DatabaseSchema).Count())
                {
                    throw new InvalidOperationException("Number of foreign key columns does not match number of columns referended!");
                }

                var referencedColumns = fk.ReferencedColumns(_table.DatabaseSchema).ToList();
                //foreach (var fkc in fk.Columns)
                for (var i = 0; i < fk.Columns.Count; i++)
                {
                    //var refColumn = referencedColumns[i];
                    //var column = fk.Columns[i];//_table.Columns.Single(tc => tc.Name == fkc);
                    var refColumn = fk.Columns[i];//_table.Columns.Single(tc => tc.Name == fkc);
                    var column = referencedColumns[i];


                    var fkPropertyName = PropertyName(_table.Columns.Single(tc => tc.Name == column));
                    var actualColumn = _table.Columns.Single(tc => tc.Name == column);
                    var s3 = $"{{ \"{refColumn}\", {entityName}.{fkPropertyName} }}";
                    dictionaryItems.Add(s3);

                    if (!actualColumn.DataType.GetNetType().IsValueType || actualColumn.Nullable)
                    {
                        propertiesNullChecks.Add($"{entityName}.{fkPropertyName} == null");
                    }
                }

                //_cb.AppendLine($"{entityName}.{propertyName} = connection.Query<{foreignKeyChild.NetName}>(@\"SELECT * FROM \"\"{foreignKeyChild.Name}\"\" WHERE \"\"{fk.Columns.First()}\"\" = @{n};\", new {{ @{n} =  {entityName}.{n}}}).AsList();");
                var dictionary = $"new Dictionary<string, object>() {{{String.Join(", ", dictionaryItems)}}}";
                if (propertiesNullChecks.Count > 0)
                {
                    using (_cb.BeginNest($"if ({String.Join(" || ", propertiesNullChecks)})"))
                    {
                        _cb.AppendLine($"{entityName}.{propertyName} = null;");
                    }

                    using (_cb.BeginNest("else"))
                    {
                        _cb.AppendLine($"{entityName}.{propertyName} = {foreignKeyChild.NetName}.GetList(c, {dictionary});");
                    }

                    _cb.AppendLine("");
                }
                else
                {
                    _cb.AppendLine($"{entityName}.{propertyName} = {foreignKeyChild.NetName}.GetList(c, {dictionary});");
                }
            }
        }

        private void WriteForeignKeyGetter(string entityName, DatabaseConstraint foreignKey)
        {
            var propertyName = _codeWriterSettings.Namer.ForeignKeyName(_table, foreignKey);
            var refTable = foreignKey.ReferencedTable(_table.DatabaseSchema);
            var dataType = refTable.NetName;

            if (foreignKey.Columns.Count != foreignKey.ReferencedColumns(_table.DatabaseSchema).Count())
            {
                throw new InvalidOperationException("Number of foreign key columns does not match number of columns referended!");
            }

            var referencedColumns = foreignKey.ReferencedColumns(_table.DatabaseSchema).ToList();
            var wheres = new List<string>();
            var parameters = new List<string>();
            var dictionaryItems = new List<string>();
            var propertiesNullChecks = new List<string>();
            for (var i = 0; i < foreignKey.Columns.Count; i++)
            {
                var refColumn = referencedColumns[i];
                var column = foreignKey.Columns[i];//_table.Columns.Single(tc => tc.Name == refColumn);
                var fkPropertyName = PropertyName(_table.Columns.Single(tc => tc.Name == column));
                var actualColumn = _table.Columns.Single(tc => tc.Name == column);

                var s1 = $"\"\"{refColumn}\"\" = @{refColumn}";
                wheres.Add(s1);

                var s2 = $"@{refColumn} = {entityName}.{fkPropertyName}";
                parameters.Add(s2);

                var s3 = $"{{ \"{refColumn}\", {entityName}.{fkPropertyName} }}";
                dictionaryItems.Add(s3);

                if (!actualColumn.DataType.GetNetType().IsValueType || actualColumn.Nullable)
                {
                    propertiesNullChecks.Add($"{entityName}.{fkPropertyName} == null");
                }
            }

            //string whereClause = String.Join(" AND ", wheres);
            //string parameterList = String.Join(", ", parameters);
            //_cb.AppendLine($"{entityName}.{propertyName} = {dataType}.Get(@\"SELECT * FROM \"\"{refTable}\"\" WHERE {whereClause};\", new {{ {parameterList} }});");
            var dictionary = $"new Dictionary<string, object>() {{{String.Join(", ", dictionaryItems)}}}";
            if (propertiesNullChecks.Count > 0)
            {
                using (_cb.BeginNest($"if ({String.Join(" || ", propertiesNullChecks)})"))
                {
                    _cb.AppendLine($"{entityName}.{propertyName} = null;");
                }

                using (_cb.BeginNest("else"))
                {
                    _cb.AppendLine($"{entityName}.{propertyName} = {dataType}.Get(c, {dictionary});");
                }

                _cb.AppendLine("");
            }
            else
            {
                _cb.AppendLine($"{entityName}.{propertyName} = {dataType}.Get(c, {dictionary});");
            }
        }

        private void WritePrimaryKey(string className)
        {
            foreach (var column in _table.Columns.Where(c => c.IsPrimaryKey))
            {
                WriteColumn(column, false);
            }

            // KE: do not use the composite class as the primary key -- we need each PK as a property for Dapper.SimpleCRUD to work
            //if (_table.HasCompositeKey)
            //{
            //    if (!IsEntityFramework())
            //    {
            //        _cb.AppendAutomaticProperty(className + "Key", "Key");
            //    }
            //    else
            //    {
            //        //code first composite key
            //        foreach (var column in _table.Columns.Where(c => c.IsPrimaryKey))
            //        {
            //            WriteColumn(column, false);
            //        }
            //    }
            //}
            //else
            //{
            //    //single primary key column
            //    var column = _table.PrimaryKeyColumn;
            //    //could be a view or have no primary key
            //    if (column != null)
            //        WriteColumn(column);
            //}
        }


        //private bool IsCodeFirst()
        //{
        //    return _codeWriterSettings.CodeTarget == CodeTarget.PocoEntityCodeFirst ||
        //        _codeWriterSettings.CodeTarget == CodeTarget.PocoEfCore;
        //}

        private bool IsEntityFramework()
        {
            return _codeWriterSettings.CodeTarget == CodeTarget.PocoEntityCodeFirst ||
                _codeWriterSettings.CodeTarget == CodeTarget.PocoRiaServices ||
                _codeWriterSettings.CodeTarget == CodeTarget.PocoEfCore;
        }

        private bool IsNHibernate()
        {
            return _codeWriterSettings.CodeTarget == CodeTarget.PocoNHibernateFluent ||
                _codeWriterSettings.CodeTarget == CodeTarget.PocoNHibernateHbm;
        }

        private void WriteUsings()
        {
            _cb.AppendLine("using System;");
            _cb.AppendLine("using System.Collections.Generic;");
            _cb.AppendLine("using System.Data;");
            _cb.AppendLine("using System.Linq;");
            _cb.AppendLine("using Dapper;");
            _cb.AppendLine("using Npgsql;");
        }

        private void WriteForeignKeyCollections()
        {
            var listType = "IEnumerable<";
            if (IsEntityFramework()) listType = "ICollection<";
            var hasTablePerTypeInheritance =
                (_table.ForeignKeyChildren.Count(fk => _table.IsSharedPrimaryKey(fk)) > 1);

            foreach (var foreignKey in _table.ForeignKeyChildren)
            {
                if (foreignKey.IsManyToManyTable() && _codeWriterSettings.CodeTarget == CodeTarget.PocoEntityCodeFirst)
                {
                    WriteManyToManyCollection(foreignKey);
                    continue;
                }
                if (_table.IsSharedPrimaryKey(foreignKey))
                {
                    if (hasTablePerTypeInheritance)
                        continue;
                    //type and property name are the same
                    _cb.AppendAutomaticProperty(foreignKey.NetName, foreignKey.NetName, true);
                    continue;
                }

                //the other table may have more than one fk pointing at this table
                var fks = _table.InverseForeignKeys(foreignKey);
                foreach (var fk in fks)
                {
                    var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKey, fk);
                    var dataType = listType + foreignKey.NetName + ">";
                    WriteForeignKeyChild(propertyName, dataType);
                }
            }
        }



        private void WriteForeignKeyChild(string propertyName, string dataType)
        {
            if (_codeWriterSettings.CodeTarget == CodeTarget.PocoRiaServices)
                _cb.AppendLine("[Include]");
            _cb.AppendAutomaticCollectionProperty(dataType, propertyName, IsNHibernate());
        }

        private void WriteManyToManyCollection(DatabaseTable foreignKey)
        {
            //look over the junction table to find the other many-to-many end
            var target = foreignKey.ManyToManyTraversal(_table);
            if (target == null)
            {
                Debug.WriteLine("Can't navigate the many to many relationship for " + _table.Name + " to " + foreignKey.Name);
                return;
            }
            var propertyName = _codeWriterSettings.Namer.NameCollection(target.NetName);
            var dataType = "ICollection<" + target.NetName + ">";
            _cb.AppendAutomaticCollectionProperty(dataType, propertyName, IsNHibernate());

        }

        private void WriteManyToManyInitialize(DatabaseTable foreignKey)
        {
            //look over the junction table to find the other many-to-many end
            var target = foreignKey.ManyToManyTraversal(_table);
            if (target == null)
            {
                return;
            }
            var propertyName = _codeWriterSettings.Namer.NameCollection(target.NetName);
            var dataType = "List<" + target.NetName + ">";
            _cb.AppendLine(propertyName + " = new " + dataType + "();");
        }

        private void InitializeCollectionsInConstructor(string className)
        {
            if (!_table.ForeignKeyChildren.Any()) return;
            using (_cb.BeginNest("public " + className + "()"))
            {
                foreach (var foreignKey in _table.ForeignKeyChildren)
                {
                    if (foreignKey.IsManyToManyTable() && _codeWriterSettings.CodeTarget == CodeTarget.PocoEntityCodeFirst)
                    {
                        WriteManyToManyInitialize(foreignKey);
                        continue;
                    }
                    if (_table.IsSharedPrimaryKey(foreignKey))
                    {
                        continue;
                    }
                    var fks = _table.InverseForeignKeys(foreignKey);
                    foreach (DatabaseConstraint fk in fks)
                    {
                        var propertyName = _codeWriterSettings.Namer.ForeignKeyCollectionName(_table.Name, foreignKey, fk);
                        var dataType = "List<" + foreignKey.NetName + ">";
                        _cb.AppendLine(propertyName + " = new " + dataType + "();");
                    }
                }
            }
            _cb.AppendLine("");
        }

        private void WriteColumn(DatabaseColumn column)
        {
            WriteColumn(column, false);
        }

        private void WriteColumn(DatabaseColumn column, bool notNetName)
        {
            if (column.DbDataType.Contains("geography") || column.DbDataType.Contains("geometry"))
            {
                return;
            }

            var propertyName = PropertyName(column);
            var dataType = _dataTypeWriter.Write(column);

            if (notNetName)
            {
                //in EF, you want a fk Id property
                //must not conflict with entity fk name
                propertyName += "Id";
            }

            _codeWriterSettings.CodeInserter.WriteColumnAnnotations(_table, column, _cb);

            var writeAnnotations = true;
            if (column.IsPrimaryKey &&
                _codeWriterSettings.CodeTarget == CodeTarget.PocoEfCore &&
                _table.PrimaryKey.Columns.Count > 1)
            {
                //EF Core doesn't like [Key] annotations on composite keys
                writeAnnotations = false;
            }
            if (writeAnnotations)
                _dataAnnotationWriter.Write(_cb, column, propertyName);
            //for code first, ordinary properties are non-virtual. 
            var useVirtual = !IsEntityFramework();
            _cb.AppendAutomaticProperty(dataType, propertyName, useVirtual);
        }

        /// <summary>
        /// Logic for propertyName. Shared with mapping.
        /// </summary>
        /// <param name="column">The column.</param>
        /// <returns></returns>
        internal static string PropertyName(DatabaseColumn column)
        {
            var propertyName = column.Name;
            //var propertyName = column.NetName;
            ////in case the netName hasn't been set
            //if (string.IsNullOrEmpty(propertyName)) propertyName = column.Name;
            //// KL: Ensures that property name doesn't match class name
            //if (propertyName == column.Table.NetName)
            //{
            //    propertyName = string.Format("{0}Column", propertyName);
            //}
            //if (column.IsPrimaryKey && column.IsForeignKey)
            //{
            //    //if it's a composite key as well, always write an Id version
            //    var table = column.Table;
            //    if (table != null && table.HasCompositeKey)
            //    {
            //        return propertyName + "Id";
            //    }
            //    //a foreign key will be written, so we need to avoid a collision
            //    var refTable = FindForeignKeyTable(column);
            //    var fkDataType = refTable != null ? refTable.NetName : column.ForeignKeyTableName;
            //    if (fkDataType == propertyName)
            //    {
            //        //in EF, you want a fk Id property
            //        //must not conflict with entity fk name
            //        propertyName += "Id";
            //    }
            //}
            return propertyName;
        }

        private static DatabaseTable FindForeignKeyTable(DatabaseColumn column)
        {
            var refTable = column.ForeignKeyTable;
            if (refTable != null) return refTable;
            //column may be in multiple fks, and the model may be broken
            var table = column.Table;
            if (table == null) return null;
            //find the first foreign key containing this column
            var fk = table.ForeignKeys.FirstOrDefault(c => c.Columns.Contains(column.Name));
            if (fk != null)
            {
                refTable = fk.ReferencedTable(table.DatabaseSchema);
            }
            return refTable;
        }

        /// <summary>
        /// KL:
        /// Similar to WriteColumn. Will send the appropriate dataType and propertyName to
        /// _cb.AppendAutomaticProperty to be written.
        /// 
        /// This method was needed to support composite foreign keys.
        /// </summary>
        /// <param name="foreignKey"></param>
        private void WriteForeignKey(DatabaseConstraint foreignKey)
        {
            // get the reference table
            var refTable = foreignKey.ReferencedTable(_table.DatabaseSchema);

            //we inherit from it instead (problem with self-joins)
            if (Equals(refTable, _inheritanceTable)) return;

            if (refTable == null)
            {
                //we can't find the foreign key table, so just write the columns
                WriteForeignKeyColumns(foreignKey, "");
                return;
            }

            var propertyName = _codeWriterSettings.Namer.ForeignKeyName(_table, foreignKey);
            var dataType = refTable.NetName;

            _cb.AppendAutomaticProperty(dataType, propertyName);

            if (IsEntityFramework() && _codeWriterSettings.UseForeignKeyIdProperties)
            {
                WriteForeignKeyColumns(foreignKey, propertyName);
            }
        }

        private void WriteForeignKeyColumns(DatabaseConstraint foreignKey, string propertyName)
        {
            //for code first, we may have to write scalar properties
            //1 if the fk is also a pk
            //2 if they selected use Foreign Key Ids
            foreach (var columnName in foreignKey.Columns)
            {
                var column = _table.FindColumn(columnName);
                if (column == null) continue;
                //primary keys are already been written
                if (!column.IsPrimaryKey)
                {
                    WriteColumn(column, propertyName.Equals(column.NetName));
                }
            }
        }

        private void WriteCompositeKeyClass(string className)
        {
            //CodeFirst can cope with multi-keys
            if (IsEntityFramework()) return;

            using (_cb.BeginNest("public class " + className + "Key", ""))
            {
                foreach (var column in _table.Columns.Where(x => x.IsPrimaryKey))
                {
                    WriteColumn(column);
                }

                var overrider = new OverrideWriter(_cb, _table, _codeWriterSettings.Namer);
                overrider.NetName = className + "Key";
                //overrider.AddOverrides();
            }
        }
    }
}
